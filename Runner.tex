\documentclass[sigplan, anonymous, 10pt]{acmart}
\usepackage{booktabs} % For formal tables
\usepackage{lipsum}
\usepackage{fancyvrb}
\newcommand{\shell}[1]{\\\texttt{\footnotesize\$ #1}\\}

\begin{document}
\title{Filesystem virtualization without containers}

\author{Void}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{Redacted}
  \streetaddress{Redacted}
  \city{Redacted} 
  \state{Redacted} 
  \postcode{12345}
}
\email{void@localhost}

\author{Null}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{Redacted}
  \streetaddress{Redacted}
  \city{Redacted} 
  \state{Redacted} 
  \postcode{12345}
}
\email{null@localhost}

% The default list of authors is too long for headers}
\renewcommand{\shortauthors}{Void et al.}

\begin{abstract}
Containers became a popular way to distribute programs in a portable fashion and to run them
under strict security constraints. However, thanks to their popularity and relatively ease
of use, users often create full-fledged containers to run mundane executables. That renders to
several complete Linux distributions being stored on the same device and brings considerable
overhead to the load and execution of those programs. This paper presents the design and
implementation of a virtualization tool that has been integrated into a full Linux-based
distribution. That tool multiplexes the root filesystem according to the dependencies of programs
executed without need for management of containers or images. Further, it seamlessly handles
dependencies managed by third-party programming language modules like PIP and LuaRocks by treating
them as first-class programs under the multiplexed filesystem tree.
\end{abstract}

\maketitle

\section{Introduction}
Dependency hell is an old problem that haunts users wishing to install programs depending on
different and often conflicting versions of a given package. That is the case of non-versioned
libraries that attempt to overwrite files from a previous installation, effectively preventing
concurrent versions of that library from coexisting. The same is true for packages whose executable
names does not change across releases; unless the user renames the existing executable file names
prior to the installation of a new version it is not possible to keep both installations around.
The problem with that approach is that it breaks package managers, as the renamed files will not
be featured in the package manager's database and, consequently, will not be tracked anymore. Further, 
unless executables depending on the renamed files are modified to reflect their new path, users need
to define which executable to activate at a given time, usually through a tricky management of
symbolic links~\cite{RHEL?}.

Besides the historical lack of support for seamlessly managing the installation and runtime
execution of programs that depend on conflicting packages, operating systems face another problem:
handling dependencies distributed by third-party software. A typical case is that of programming
language modules: each programming language community packs and hosts modules according to their own
format and enables their discovery and installation through special programs that many times are not
properly integrated with the regular package manager. Examples include PIP, which manages Python
packages, LuaRocks, which controls the installation and removal of Lua modules, CPAN, to control the
installation of Perl packages, and RubyGems, which does the same for Ruby packages. Orchestrating
dependencies managed by such a variety of programs can be quite complex.

Many approaches have emerged through the years to work around the problem. In common, they propose
encapsulation techniques that let software vendors ship their programs along with their dependencies
in a single file and that let users execute said software effortlessly. Virtual machine images
became a very popular distribution format in the early 2000's~\cite{Who?}, followed more recently by
container images~\cite{fink2014:docker} that became possible thanks to advancements in microprocessor
architectures~\cite{uhlig2005:vtx, amd2005:svm} and in operating systems support for virtualization
~\cite{russell2008:virtio, dall2014:kvm+arm, kivity2007:kvm}. 

\textbf{XXX mention very briefly how virtualization and containerization works.}
\lipsum[1]

In spite
of their success, an ever growing number of mundane programs gained their containerized version,
even when those have no dependencies other than basic system libraries. As a result, users end up
with several full-blown copies of operating system images that need to be managed in addition to
the regular package management for fundamental operating system services.

\textbf{Falar sobre os overheads ocultos de gerenciamento de containers.}

This paper presents a novel approach to the management and execution of programs that depends
solely on changes to the layout of the filesystem hierarchy and on private process namespaces.
Our lightweight proposal to filesystem virtualization has been fully integrated into a Linux-based
distribution and includes support for both basic programs (such as those typically managed by RPM
and DEB) and those managed by third-party software such as PIP and LuaRocks.

The remaining of the paper is organized as follows. Section~\ref{sec:foo} presents \ldots

\section{Prior art}

Write about AppImages.

Snap is a technology built for creating and distributing universal packages on Linux-based
operating systems. Proposed by Canonical, the format is based on a read-only SquashFS filesystem
image that contains the application of interest along with its dependencies. A metadata file
included in the image determines the package name, its version, and the command line required
to execute the software, along with other information~\cite{canonical2011:snapcraft}.
It is also possible to run the program in a confined sandbox enforced by AppArmor, a Linux kernel
security module that allows fine-grained control over user applications (albeit requiring greater
expertise to be configured than typical end users can reasonably be expected to
have~\cite{schreuders2011:empowering}).

Because Snap programs execute in an isolated environment, communication with other parties
and resource sharing must be arranged through predefined \emph{interfaces}. Such interfaces
coordinate access to services such as sound card devices, bluetooth controllers, filesystem
areas, printing services, and so on, and require a consumer in one end (called a ``plug''
in Snap nomenclature) and a provider (``slot''). Although some basic interfaces are automatically
connected by default (such as ones considered transitional to support traditional desktop
environments), most interfaces need to be manually connected by the user. Lastly, because
an entire ecosystem of dependencies is encapsulated in a Snap package, there can be several
redundant files replicated over Snap packages of different applications.

Flatpak serves the same purpose as Snap: it provides a mechanism to distribute packages
across Linux-based distributions in a portable fashion. Differently from Snap, Flatpak
uncompresses and stores the packages in the target filesystem under a shared directory
that contains data from other Flatpak packages. By doing so, Flatpak is able to detect
redundant files and to store only a single copy of the files. That is achieved with the
use of hard links. Limits are managed through Linux Seccomp, a facility that enables
the creation of filters that, on Flatpak, can be used to disable certain system calls
issued by the application~\cite{lwn2015:seccomp}. Several private namespace settings
also exist to control access to the network and to other processes outside the sandbox.
As with Snap, fine tuning such rules requires a deep knowledge of the application being
contained as well as of the system calls and resources it uses.

Explain how Docker~\cite{fink2014:docker} works.
\lipsum[1-2]

GNU Guix~\cite{courtes2013:guix} is a transactional package manager based on Nix~\cite{dolstra2004:nix}.
It supports transactional upgrades and
roll-backs of packages through the installation of packages under unique prefixes on the filesystem.
Such prefixes include the program name and a hash string that is calculated over the program's
build inputs. For instance, two distinct versions of the Python interpreter could be installed
under \texttt{/gnu/store/[sha256-hash]-python-2.7.12} and \texttt{/gnu/store/[sha256-hash]-python-3.6.0},
each of which having their own \texttt{bin}, \texttt{include}, \texttt{lib}, and \texttt{share}
subdirectories. If another builds of Python 2.7.12 were to be installed (using different optimization
flags, for example) then a different hash would be computed for that particular build, enabling its
installation on a different prefix than the old version of that same program. There is an entire
distribution called GuixSD that is built around GNU Guix.

Guix comes with an utility that lets one create ``application bundles'' from a set of package
definitions~\cite{gnu2017:bundles}. Given a list of programs (and, optionally, their dependencies),
the corresponding entries under \texttt{/gnu/store} are copied into a tar file. Users then only
need to extract that tarball on another machine in order to run the program. In order to circumvent
the embedding of absolute file names on executables (e.g., the path to the dynamic linker, locale
data, shared data, and others) that would otherwise prevent non-GuixSD distributions from running
that program, Guix ``relocates'' their packages using Linux user namespaces. A statically-linked
wrapper is automatically generated by Guix to populate a private \texttt{/gnu/store} directory
from the contents of the tar file that is only made visible to the wrapper process and its
children~\cite{gnu2018:tarballs}.

Despite the rich infrastructure built around the installation and execution of regular programs,
Guix does not provide support for the virtualization of programming language modules. In practice,
such modules will be installed under their corresponding Python/Lua/Guile/Perl/etc directories
under \texttt{/gnu/store} unless the corresponding third-party managers are told to install them
elsewhere.


\section{Container-free filesystem virtualization}

\subsection{The layout of the filesystem tree}
Our approach to virtualization came up as a natural evolution of the filesystem tree proposed
by GoboLinux~\cite{GoboLinux}. Instead of having parts of a program copied to \texttt{/usr/bin},
other parts to \texttt{/etc} and yet more parts copied to \texttt{/usr/share/something}, on
GoboLinux each program gets its own directory tree that are kept separated from each other.
The distribution uses a directory structure that, albeit similar to the one used by Nix and
Guix, predates them and extends the concept to the entire filesystem tree.

The root filesystem contains directories named \texttt{Data}, \texttt{Mount}, \texttt{Programs},
\texttt{System}, and \texttt{Users}. Programs are installed under \texttt{/Programs/Name/Version}.
That directory holds not only the program's libraries, executables, headers, and shared files, but
also metadata that describes which programs it depends on (\texttt{Resources/Dependencies}), any
environment variables that must be configured prior to running executables distributed by that
program (\texttt{Resources/Environment}, the target architecture of the executables
(\texttt{Resources/Architecture}), and others.

The Dependencies file is described with a simple syntax. Each line of that file determines
a particular dependency, given by its directory under \texttt{/Programs} and, optionally,
which version of that dependency is required. It is possible to specify ranges using the
symbols $<$, $>$, and $=$, as in \texttt{LibFoo = 1.3} or \texttt{LibBar >= 1.0, < 2.0}.
Given the layout of the \texttt{/Programs} tree it is trivial to determine whether a given
dependency is satisfied and to determine which installed version of a dependency is the most
recent one supported by a program.

The Dependencies file also allows one to describe dependencies managed by third-party
software. Those are prefixed by \texttt{PIP:}, \texttt{CPAN:}, \texttt{LuaRocks:}, and
\texttt{RubyGems:}, followed by the package name. The difference regarding the dependency
resolution, in this case, is that testing whether that dependency is installed or not is
delegated to the corresponding third-party package manager.

All executables, libraries, headers, and shared files are indexed on \texttt{/System/Index};
that directory contains the typical \texttt{bin}, \texttt{include}, \texttt{lib}, \texttt{libexec},
and \texttt{share} entries, along with the symbolic links \texttt{sbin $\rightarrow$ bin} and
\texttt{lib64 $\rightarrow$ lib}. The files inside these directories are symbolic links to the
most recent version of each program installed on the system or, alternatively, to a version
configured by the user.

The Linux Hierarchy Standard (LHS)~\cite{lsb2015:fhs} defines support for
multiarch libraries (e.g., libraries built for i686 on an x86-64 platform)
through directories named \texttt{/lib32} and \texttt{/lib64},
where 32 and 64 are determined according to the architecture's pointer size.
This solution does not work well once multiple 64 or 32-bit architectures must
be supported due to namespace conflicts. An alternative approach would be to define
multiple suffixes that reflect the target architecture, such as \texttt{/lib\_ia64}
and \texttt{/lib\_x64\_64}, but the number of library directories quickly grow and
difficults the maintenance of fundamental system services~\cite{heen2005:thesis}.
The layout of the filesystem tree we defined on GoboLinux includes a symbolic link
\texttt{lib64 $\rightarrow$ lib} for backwards compatibility purposes alone so that
an executable searching for that directory can find it.

In order to enable existing programs and scripts from running without modifications on
the top of this filesystem tree, compatibility links such as
\texttt{/bin $\rightarrow$ /System/Index/bin} and
\texttt{/usr/include $\rightarrow$ /System/Index/include} exist, effectively letting
executables and libraries to be found regardless of where they are searched for.
The compatibility links are hidden from userspace programs for aesthetical reasons
by an optional kernel extension developed by the distribution~\cite{GoboHide}.

\subsection{Augmented filesystem tree}
We hereby present the first contribution of this paper. AlienVFS is a novel virtual
filesystem that we developed that mirrors modules installed by programming language
package managers under a centralized directory. In other words, modules installed
through CPAN, LuaRocks, PIP, RubyGems, and other supported languages are exposed under
a single mount point. The virtual directory presents the module name and one or more
subdirectories holding the installed version(s) of that module, as shown on
Figure~\ref{fig:alienvfs}.

\begin{figure}
    \begin{Verbatim}[frame=single]
$ ls /Mount/Aliens
CPAN:Authen::SASL     PIP3:numpy
CPAN:Digest::HMAC     PIP3:urllib3
CPAN:Encode::Locale   PIP:Flask
LuaRocks:inotify      PIP:pycairo
LuaRocks:lanes        PIP:sqlparse
PIP3:dbus-python      RubyGems:rake
PIP3:flasgger         RubyGems:xmlrpc
...                   ...

$ ls /Mount/Aliens/PIP:sqlparse
0.2.4

$ ls /Mount/Aliens/PIP:sqlparse/0.2.4
bin  sqlparse  sqlparse-0.2.4.dist-info
    \end{Verbatim}
    \caption{Programming language modules exposed as regular programs with AlienVFS}
    \label{fig:alienvfs}
\end{figure}

AlienVFS creates an in-memory mapping of the programming language modules installed
by either interacting with the corresponding package manager or by parsing manifest
files found in well known locations. The same approach is used to determine the
name and version of the modules that are used to compose the top-level directories
of the virtual filesystem tree. The following backends are supported by our initial
implementation of AlienVS:

\begin{itemize}
    \item CPAN: provides support for Perl modules. Modules names and file listings
        are obtained from \emph{packlist} manifests under the directories reported
        by the \texttt{perldoc} utility;
    \item LuaRocks: installed Lua modules along with their paths are retrieved
        through interaction with the \texttt{luarocks} package manager;
    \item PIP and PIP3: the lists of files installed by Python 2.x and 3.x modules
        are obtained by parsing Egg-Info and Dist-Info manifests;
    \item RubyGems: implements support for Ruby modules. The module search location
        and the list of installed files are obtained by direct interaction with the
        \texttt{gem} package manager.
\end{itemize}

The virtual filesystem is implemented as a FUSE daemon~\cite{miklos2001:fuse} that
redirects system calls (such as \texttt{stat} and \texttt{read}) to the original
location where the modules are installed.

Since AlienVFS mimics the structure of regular packages installed under
\texttt{/Programs}, we can merge them using an overlay filesystem~\cite{brown2018:overlayfs}
and provide a unified view of installed programs and programming language modules, as
shown in Figure~\ref{fig:alienvfs.merged}.

\begin{figure}[h]
    \begin{Verbatim}[frame=single]
$ ls /Programs
ALSA-Lib              Pinfo
BinUtils              Pixman
CoreUtils             PIP3:dbus-python
CPAN:Authen::SASL     PIP3:flasgger
CPAN:Digest::HMAC     PIP3:numpy
CPAN:Encode::Locale   PIP3:urllib3
...                   ...
LuaRocks              PIP:sqlparse
LuaRocks:inotify      Pkgconfig
LuaRocks:lanes        PostgreSQL
...                   ...
    \end{Verbatim}
    \caption{Overlay of AlienVFS on /Programs}
    \label{fig:alienvfs.merged}
\end{figure}

The merged layout makes it easier for users to navigate their filesystem tree
and inspect programming modules files of their interest. Further, it enables a
much simpler implementation of dependency checkers: as long as the expected
directory exists under /Programs, the dependency is met -- no matter if the
dependency is a regular program or a programming language module.

\subsection{Lightweight filesystem virtualization without containers}
In this section we present the second contribution of this paper. Runner is a
filesystem multiplexer that we created to enable the resolution of conflicting
dependencies at runtime. It is conceptually similar to the statically-linked
wrappers recently introduced on Guix, but suitable to the layout of the
\texttt{/Programs} tree and supporting multiarch executables and libraries
in a rather unique way.

Runner works by creating private mounts for each program it executes. The
private mounts are composed by \texttt{/System/Index} with overlays mounts
of each dependency of that program. The dependency list can be given either
explicitly with a Dependencies file or implicitly by inferring the location
where that program is installed. If the executable happens to come from
\texttt{/Programs}, then that program's \texttt{Resources/Dependencies}
file is parsed by default. Also, if a dependency happens to have more than
one installed version, then any existing files from other versions of that
dependency are removed from the private mount point of that process. This
ensures that only a single version of a dependency is ``active'' at a time.

XXX write about multiarch support (ELF + Resources/Architecture)
\lipsum[7]

XXX write about Resources/Environment
\lipsum[8]

\section{Thoughts and comparison with the prior art}
Things to note: containers can limit access to underlying hardware infrastructure, segment the
network, and so on. They provide a complex infrastructure that lets system administrators to
confine the execution of programs in a way that eases the control of available resources.

We have developed and deployed our system on a Linux-based distribution.

XXX say that we have been successfully using Runner to enable multiple GCC versions.
That is needed by CUDA, for instance, which depends on specific versions of the compiler.

\lipsum[9-13]

\section{Conclusion}
This paper presented a container-free infrastructure to manage and run programs that have
conflicting dependencies. 

\lipsum[14-16]

\bibliographystyle{ACM-Reference-Format}
\bibliography{Runner}

\end{document}
